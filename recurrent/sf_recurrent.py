import strawberryfields as sf
import numpy as np
import torch
from torch import nn

# Number of layers of the Dolinar receiver. Selecting 4 as the most basic,
# non-trivial case.
NUM_LAYERS = 4

# Number of quantum modes. Basic 2-mode case.
NUM_MODES = 2

# Signal amplitude. Default is 1.0.
SIGNAL_AMPLITUDE = 1.0

# Fock backend.
ENGINE = sf.Engine("fock", backend_options={"cutoff_dim": 6})


def generate_nth_layer(layer_number, engine):
    """Generates the nth layer of the Dolinar receiver.
    Given the `layer_number` and `engine` as input, it returns a
    function that generates the necessary quantum circuit for the n-th layer of
    the Dolinar receiver.
    """

    # Need k values for the splits of the coherent state.
    amplitudes =  np.ones(NUM_LAYERS) * (SIGNAL_AMPLITUDE / NUM_LAYERS)

    def quantum_layer(input_codeword, displacement_magnitudes_for_each_mode):
        program = sf.Program(NUM_MODES)

        with program.context as q:
            # Prepare the coherent states for the layer. Appropriately scales
            # the amplitudes for each of the layers.
            for m in range(NUM_MODES):
                sf.ops.Coherent(amplitudes[layer_number] * input_codeword[m]) | q[m]

            # Displace each of the modes by using the displacement magnitudes
            # generated by the ML backend.
            for m in range(NUM_MODES):
                sf.Dgate(displacement_magnitudes_for_each_mode[m]) | q[m]

            # Perform measurements.
            sf.ops.MeasureFock() | q

        return engine.run(program)

    return quantum_layer


class Model(nn.Module):
    """
    Defines a basic neural network model that predicts the values of the
    displacement magnitudes.
    """
    def __init__(self, *, input_dim, output_dim, name=None):
        super().__init__()

        self.name = name

        self.input_dim = input_dim
        self.output_dim = output_dim

        self.network_stack = nn.Sequential(
            nn.Linear(self.input_dim, 32),
            nn.ReLU(),
            nn.Linear(32, self.output_dim),
            nn.Softmax())

    def forward(self, input_data):
        return self.network_stack(input_data)


if __name__ == '__main__':
    # ML model to predict the displacement magnitude for each of the layers of
    # the Dolinar receiver.

    # TODO: Decide on model architecture.
    model = Model(input_dim=None, output_dim=None, name="basic_model")

    # Layers of the Dolinar receiver.
    layers = [generate_nth_layer(n, model, ENGINE) for n in range(NUM_LAYERS)]

    # TODO: Add previous measurement to current layer and use it while calling the
    # predictor to obtain the new displacement values for the layer.

    # TODO: Add training loop.
