"""
Encapsulates and isolates the quantum circuit.
"""

import numpy as np
import strawberryfields as sf

class QuantumBox:
    def __init__(self, config):
        # Config.
        self.NUM_LAYERS = config.NUM_LAYERS
        self.SIGNAL_AMPLITUDE = config.SIGNAL_AMPLITUDE
        self.NUM_LAYERS = config.NUM_LAYERS
        self.NUM_MODES = config.NUM_MODES

        # Use fock backend for simulation.
        self.CUTOFF_DIM = config.CUTOFF_DIM
        self.engine = sf.Engine("fock",
                                backend_options={
                                    "cutoff_dim": self.CUTOFF_DIM
                                })

    def __call__(self, layer, input_codeword, displacement_magnitudes_for_each_mode):
        # Reset engine if a program has been executed.
        if self.engine.run_progs:
            self.engine.reset()

        # Need k values for the splits of the coherent state.
        amplitudes =  np.ones(self.NUM_LAYERS) * (self.SIGNAL_AMPLITUDE / self.NUM_LAYERS)

        program = sf.Program(self.NUM_MODES)

        mapping = {}
        params = {}

        for nth_mode in range(self.NUM_MODES):
            params[f"input_codeword_arg_{nth_mode}"] =  program.params(f"input_codeword_arg_{nth_mode}")
            mapping[f"input_codeword_arg_{nth_mode}"] = input_codeword[nth_mode]

            params[f"displacement_magnitudes_for_each_mode_arg_{nth_mode}"] =  program.params(f"displacement_magnitudes_for_each_mode_arg_{nth_mode}")
            mapping[f"displacement_magnitudes_for_each_mode_arg_{nth_mode}"] = displacement_magnitudes_for_each_mode[nth_mode]

        # TODO: Use a different quantum circuit.
        with program.context as q:
            # Prepare the coherent states for the layer. Appropriately scales
            # the amplitudes for each of the layers.
            for m in range(self.NUM_MODES):
                sf.ops.Coherent(amplitudes[layer] * params[f"input_codeword_arg_{m}"]) | q[m]

            # Displace each of the modes by using the displacement magnitudes
            # generated by the ML backend.
            for m in range(self.NUM_MODES):
                sf.ops.Dgate(params[f"displacement_magnitudes_for_each_mode_arg_{m}"]) | q[m]

            # Perform measurements.
            sf.ops.MeasureFock() | q

        return self.engine.run(program, args=mapping)
